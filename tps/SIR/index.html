<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="S√©bastien Boisg√©rault, MINES ParisTech" name="author"/>
<title>Le mod√®le √©pid√©miologique SIR</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Le mod√®le √©pid√©miologique SIR</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@mines-paristech.fr">S√©bastien
Boisg√©rault</a>, MINES ParisTech</p>
<p class="date">Mercredi 18 mai 2022</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/84940ec">
          #84940ec
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/edit.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/edit/master/tps/SIR/index.md">
          Edition
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des mati√®res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#d√©pendances" id="toc-d√©pendances">D√©pendances</a></li>
<li><a href="#simulation" id="toc-simulation">Simulation</a></li>
<li><a href="#visualisation" id="toc-visualisation">Visualisation</a></li>
<li><a href="#configuration" id="toc-configuration">Configuration</a></li>
<li><a href="#temps-continu" id="toc-temps-continu">Temps
continu</a></li>
<li><a href="#ev√®nements" id="toc-ev√®nements">Ev√®nements</a></li>
<li><a href="#g√©n√©ration-de-dynamique" id="toc-g√©n√©ration-de-dynamique">G√©n√©ration de dynamique</a></li>
</ul>
</nav></details>


<h2 id="introduction">Introduction</h2>
<p>Le mod√®le √©pid√©miologique √† compartiments SIR d√©termine l‚Äô√©volution
dans le temps, parmi une population suppos√©e constante de <span class="math inline">\(N\)</span> individus, du nombre d‚Äôindividus
susceptibles d'√™tre infect√©s <span class="math inline">\(S\)</span>, du
nombre d‚Äôindividus infect√©s <span class="math inline">\(I\)</span> et du
nombre d‚Äôindividus en r√©mission (n‚Äôayant plus de sympt√¥mes cliniques)
<span class="math inline">\(R\)</span> (cf.¬†<a href="https://www.nature.com/articles/s41592-020-0856-2">‚ÄúThe SEIRS
model for infectious disease dynamics‚Äù</a> pour la pr√©sentation d‚Äôun
mod√®le plus complet).</p>
<p>Le param√®tre <span class="math inline">\(\beta&gt;0\)</span>
repr√©sente le taux de contagion, <span class="math inline">\(\gamma&gt;0\)</span> le taux de gu√©rison et <span class="math inline">\(\omega&gt;0\)</span> le taux de perte d‚Äôimmunit√©
(ces grandeurs sont homog√®nes √† l‚Äôinverse d'un temps). On d√©finit le
nombre de reproduction de base <span class="math inline">\(R_0\)</span>
par</p>
<p><span class="math display">\[
R_0 := \frac{\beta}{\gamma}
\]</span></p>
<p>En l'absence de naissances et de morts, ces grandeurs √©voluent selon
les √©quations :</p>
<p><span class="math display">\[
\dot{S}(t) = \omega R(t) - \beta \frac{I(t)S(t)}{N}
\]</span></p>
<p><span class="math display">\[
\dot{I}(t) = \beta \frac{I(t)S(t)}{N} - \gamma  I(t)
\]</span></p>
<p><span class="math display">\[
\dot{R}(t) = \gamma I(t) - \omega R(t)
\]</span></p>
<h2 id="d√©pendances">D√©pendances</h2>
<p>Python 3, NumPy, SciPy, Matplotlib.</p>
<pre class="python"><code>from numpy import *
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt</code></pre>
<h2 id="simulation">Simulation</h2>
<p>On d√©finit les constantes</p>
<pre class="python"><code>WEEK = 7
YEAR = 365</code></pre>
<p>et</p>
<pre class="python"><code>N = 100
beta = 1 / (WEEK)
gamma = 1 / (2 * WEEK)
omega = 1 / YEAR</code></pre>
<h4 id="simulation-avec-solve_ivp">üöÄ Simulation avec
<code>solve_ivp</code></h4>
<p>D√©velopper une fonction <code>dSIR</code> telle que le code</p>
<pre class="python"><code>S0, I0 = 99.0, 1.0
R0 = N - S0 - I0
t_span = [0.0, 5*YEAR]
results = solve_ivp(dSIR, t_span=t_span, y0=(S0, I0, R0))</code></pre>
<p>fournisse les r√©sultats d‚Äôune simulation du mod√®le SIR sur 5 ans avec
une population initiale de 1 % de personnes infect√©es.</p>
<p>(R√©f√©rence : üìñ <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"><code>solve_ivp</code></a>)</p>
<details>
<summary>
<h4 id="solution">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def dSIR(t, SIR):
    S, I, R = SIR
    dS = omega * R - beta * I * S / N
    dI = beta * I * S / N - gamma * I
    dR = gamma * I - omega * R  
    return (dS, dI, dR)</code></pre>
<p>Si vous √™tes familier des fermetures, et que la pr√©sence d‚Äôun
argument <code>t</code> ‚Äúqui ne sert √† rien‚Äù vous titille, vous pouvez
√©galement d√©finir la fonction d‚Äôordre sup√©rieur</p>
<pre class="python"><code>def autonomous(fx):
    def f_tx(t, x):
        return fx(x)
    return f_tx</code></pre>
<p>et l‚Äôexploiter comme un d√©corateur pour d√©finir <code>dSIR</code>
sans le param√®tre <code>t</code> :</p>
<pre class="python"><code>@autonomous
def dSIR(SIR):
    S, I, R = SIR
    dS = omega * R - beta * I * S / N
    dI = beta * I * S / N - gamma * I
    dR = gamma * I - omega * R  
    return (dS, dI, dR)</code></pre>
</details>
<h2 id="visualisation">Visualisation</h2>
<h4 id="visualisation-des-r√©sultats">üöÄ Visualisation des r√©sultats</h4>
<p>D√©veloppez une fonction <code>plot</code> √† invoquer par :</p>
<pre class="python"><code>plot(**results)</code></pre>
<p>qui produise le graphique :</p>
<p><img src="images/SIR-discrete.svg"/></p>
<details>
<summary>
<h4 id="solution-1">‚ú® Solution</h4>
</summary>
<p>Les donn√©es dont nous avons besoin dans le dictionnaire
<code>results</code> sont associ√©es aux cl√©s <code>"t"</code> et
<code>"y"</code>. Si elles √©taient les seules donn√©es pr√©sentes dans
<code>results</code>, nous pourrions d√©finir une fonction
<code>plot</code> de signature :</p>
<pre class="python"><code>def plot(t, y):
    pass</code></pre>
<p>et l‚Äôappel <code>plot(**results)</code> assignerait aux param√®tres
<code>t</code> et <code>y</code> les donn√©es correspondantes de
<code>result</code>. Mais en pratique, <code>results</code> contient
d‚Äôautre donn√©es :</p>
<pre class="python"><code>&gt;&gt;&gt; list(results.keys())
['t', 'y', 'sol', 't_events', 'y_events', 'nfev', ...]</code></pre>
<p>Or √† ce stade notre fonction n‚Äôaccepte pas les param√®tres nomm√©s
<code>sol</code>, <code>t_events</code>, etc. L‚Äôappel √†
<code>plot</code> √©choue donc logiquement :</p>
<pre class="python"><code>&gt;&gt;&gt; plot(**result)
Traceback (most recent call last):
...
TypeError: plot() got an unexpected keyword argument 'sol'</code></pre>
<p>Une fa√ßon de changer cette situation est d‚Äôintroduire un
‚Äúramasse-miettes‚Äù, sous la forme d‚Äôun dictionnaire collectant les
donn√©es de<code>result</code> qui ne sont pas associ√©es aux cl√©s
<code>"t"</code> ou <code>"y"</code>. Pour ce faire, la notation
<code>**</code> est utilis√©e ; le dictionnaire associ√© est ici nomm√©
<code>_</code> pour indiquer qu‚Äôon ne fera pas usage de son contenu
(cela n‚Äôest pas obligatoire, juste une convention).</p>
<pre class="python"><code>def plot(t, y, **_):
    print(list(_.keys()))</code></pre>
<pre class="python"><code>&gt;&gt;&gt; plot(**results)
['sol', 't_events', 'y_events', ...]</code></pre>
<p>Avec cette technique, la fonction suivante fait l‚Äôaffaire :</p>
<pre class="python"><code>def plot(t, y, **_):
    plt.plot(t, y.T, "-+", label=["S", "I", "R"])
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
</details>
<h2 id="configuration">Configuration</h2>
<p>Apr√®s examen de vos r√©sultats pr√©liminaires, les sp√©cialistes de la
dynamique vous font par de r√©glages √† effectuer sur la m√©thode du
simulation. Leurs pr√©conisations prennent la forme d‚Äôun fichier
<code>options.py</code> √† utiliser avec <code>solve_ivp</code> :</p>
<pre class="python"><code>{
    "method": "Radau",
    "rtol": 1e-3,
    "atol": 1e-6
}</code></pre>
<h4 id="r√©glages">üöÄ R√©glages</h4>
<p>Prenez en compte le fichier d‚Äôoptions que l‚Äôon vous a donn√©.</p>
<details>
<summary>
<h4 id="solution-2">‚ú® Solution</h4>
</summary>
<pre class="python"><code>options = eval(open("options.py").read())
results = solve_ivp(
    dSIR, 
    t_span=t_span, 
    y0=(S0, I0, R0), 
    **options
)</code></pre>
<p><img src="images/SIR-options.svg"/></p>
</details>
<h2 id="temps-continu">Temps continu</h2>
<p>Lorsque <code>solve_ivp</code> est invoqu√© avec
<code>dense_output=True</code></p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    t_span=t_span, 
    y0=(S0, I0, R0), 
    dense_output=True
)</code></pre>
<p>ses r√©sultats comportent, en plus des donn√©es discr√®tes
<code>t</code> et <code>y</code>, une approximation de la solution comme
une fonction du temps.</p>
<pre class="python"><code>&gt;&gt;&gt; sol = results["sol"]</code></pre>
<p>Cette fonctionalit√© nous permet de r√©aliser une nouvelle version de
la fonction <code>plot</code>, telle que :</p>
<pre class="python"><code>&gt;&gt;&gt; t = arange(0, 5*YEAR) # a value every day for 5 years.
&gt;&gt;&gt; plot(t, **results)</code></pre>
<p>produise le graphique :</p>
<p><img src="images/SIR-dense.svg"/></p>
<h4 id="exploitation-des-dense-outputs">üöÄ Exploitation des ‚Äúdense
outputs‚Äù</h4>
<p>V√©rifier que <code>sol</code> est invocable, puis d√©velopper une
nouvelle version de la fonction <code>plot</code> exploitant les ‚Äúdense
outputs‚Äù de <code>solve_ivp</code> pour r√©aliser le graphe voulu.</p>
<details>
<summary>
<h4 id="solution-3">‚ú® Solution</h4>
</summary>
<pre class="python"><code>&gt;&gt;&gt; sol = results["sol"]
&gt;&gt;&gt; sol
&lt;scipy.integrate._ivp.common.OdeSolution at ...&gt;
&gt;&gt;&gt; callable(sol)
True</code></pre>
<pre class="python"><code>def plot(t_, sol, **_):
    plt.plot(t_, sol(t_).T, "-", label=["S", "I", "R"])
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
</details>
<h2 id="ev√®nements">Ev√®nements</h2>
<h4 id="seuils-dinfection">üöÄ Seuils d‚Äôinfection</h4>
<p>Utiliser le param√®tre <code>events</code> de <code>solve_ivp</code>
pour d√©tecter les instants o√π le nombre d‚Äôinfect√©s passe en-dessous ou
au-dessus de 10 %. Adapter une nouvelle fois la fonction
<code>plot</code> pour repr√©senter ces √©v√®nements comme des points noirs
sur la courbe associ√©e √† la variable <span class="math inline">\(I\)</span>.</p>
<p><img src="images/SIR-events.svg"/></p>
<p>Comment r√©organiser votre programme pour prendre en charge facilement
un seuil d‚Äôinfection arbitraire et non pas fixe √† 10 % ?</p>
<details>
<summary>
<h4 id="solution-4">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def event(t, SIR):
    S, I, R = SIR
    return I - 10.0</code></pre>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[event]
)</code></pre>
<pre class="python"><code>def plot(t_, sol, t_events, **_):
    plt.plot(t_, sol(t_).T, "-", label=["S", "I", "R"])
    t_event = t_events[0]
    plt.plot(t_event, sol(t_event)[1], "k.")
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
<p>La solution ‚Äú√©vidente‚Äù pour prendre en charge une seuil limite qui
peut varier est d‚Äôutiliser une variable globale :</p>
<pre class="python"><code>I_max = 2.0

def event(t, SIR):
    S, I, R = SIR
    return I - I_max</code></pre>
<p>L‚Äôavantage est que le code appelant la simulation est inchang√© :</p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[event]
)</code></pre>
<pre class="python"><code>&gt;&gt;&gt; plot(t, **results)</code></pre>
<p><img src="images/SIR-events-2.svg"/></p>
<p>Si vous n‚Äôaimez pas beaucoup les variables globales, vous pouvez les
√©viter en utilisant une fonction d‚Äôordre sup√©rieur qui renvoie une
fonction <code>event</code> :</p>
<pre class="python"><code>def I_crosses(I_threshold):
    def event(t, SIR):
        S, I, R = SIR
        return I - I_threshold
    return event</code></pre>
<p>Vous l‚Äôexploitez alors de la fa√ßon suivante :</p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[I_crosses(2.0)]
)</code></pre>
<p>avec les m√™me r√©sultats que pr√©c√©demment</p>
</details>
<h2 id="g√©n√©ration-de-dynamique">G√©n√©ration de dynamique</h2>
<p>Vous avez sans doute remarqu√© que la dynamique du mod√®le SIR est
enti√®rement d√©termin√©e par les flux existant entre les ‚Äúcompartiments‚Äù
de population <span class="math inline">\(S\)</span>, <span class="math inline">\(I\)</span> et <span class="math inline">\(R\)</span>, qui peuvent √™tre d√©crits par la
structure :</p>
<pre class="python"><code>SIR_dynamics = {
 ("S", "I"): "beta * I * S / N",
 ("I", "R"): "gamma * I",
 ("R", "S"): "omega * R"
}</code></pre>
<p>Au lieu d‚Äô√©crire ‚Äú√† la main‚Äù la fonction <code>dSIR</code> comme
pr√©c√©demment, on peut d√©finir une fonction <code>make_d_state</code> qui
prend comme argument le type de dictionnaire ci-dessus et produit
automatiquement la fonction <code>dSIR_auto</code><a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>
:</p>
<pre class="python"><code>dSIR_manu = dSIR
dSIR_auto = make_dstate(SIR_dynamics)</code></pre>
<h4 id="cr√©ation-du-champ-de-vecteurs-de-la-dynamique">üöÄ Cr√©ation du
champ de vecteurs de la dynamique</h4>
<p>Impl√©menter la fonction <code>make_dstate</code>. On v√©rifiera que
les comportements de la version manuelle et automatique sont identiques.
Par exemple :</p>
<pre class="python"><code>&gt;&gt;&gt; dSIR_manu(0.0, (1/3, 1/3, 1/3))
(0.0007545118504022613, -0.023650793650793648, 0.02289628180039139)
&gt;&gt;&gt; dSIR_auto(0.0, (1/3, 1/3, 1/3))
(0.0007545118504022613, -0.023650793650793648, 0.02289628180039139)</code></pre>
<details>
<summary>
<h4 id="solution-5">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def get_vars(dynamics):
    vars = []
    for pair in dynamics.keys():
        vars.extend(pair)
    # remove duplicated vars
    return list(set(vars))</code></pre>
<pre class="python"><code>&gt;&gt;&gt; get_vars(SIR_dynamics)
['S', 'I', 'R']</code></pre>
<pre class="python"><code>def make_dstate(dynamics):
    vars = get_vars(dynamics)
    
    def fun(t, state):
        ns = globals().copy()
        for var, value in zip(vars, state):
            ns[var] = value
        dstate = []
        for var in vars:
            d = 0
            for (edge, expr) in dynamics.items():
                source, target = edge
                if source == var:
                    d -= eval(expr, ns)
                if target == var:
                    d += eval(expr, ns)
            dstate.append(d)
        return dstate
        
    return fun </code></pre>
</details>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>On peut ainsi √©viter les erreurs dans
la traduction du mod√®le de flux en √©quations diff√©rentielles, d√©finir
plus rapidement de nouveaux mod√®les compartimentaux, etc.<a class="footnote-back" href="#fnref1" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
</body>
</html>
